const CODE_TABLE_QUOTE_LIST = /* @__PURE__ */ new Set([
  "code",
  "table",
  "blockquote",
  "list",
  "mdxJsxFlowElement"
]);
const remarkStructurize = (options) => {
  const opts = { codeblocks: true, ...options };
  const structurizedData = /* @__PURE__ */ Object.create(null);
  let activeSlug = "";
  let skip = false;
  let content = "";
  return (tree, file) => {
    walk(tree);
    save();
    file.data.structurizedData = structurizedData;
  };
  function save() {
    const cleanedContent = content.trim().replaceAll(/\w{50,}/g, "").replaceAll(/\n+/g, "\n");
    if (activeSlug || cleanedContent) {
      structurizedData[activeSlug] = cleanedContent;
    }
  }
  function walk(node) {
    let result = "";
    const { type } = node;
    if (type === "heading") {
      skip = true;
    }
    if (CODE_TABLE_QUOTE_LIST.has(type)) {
      result += "\n";
      if (!skip) content += "\n";
    }
    if ("children" in node) {
      for (const child of node.children) {
        result += walk(child);
      }
    } else if (opts.codeblocks && type === "code" || type === "text" || type === "inlineCode" || type === "tableCell") {
      const value = type === "inlineCode" ? node.value.replace(/\{:\w+}$/, "") : node.value;
      result += value;
      if (!skip) content += value;
    }
    if (CODE_TABLE_QUOTE_LIST.has(type) || ["listItem", "break"].includes(type)) {
      result += "\n";
      if (!skip) content += "\n";
    }
    if (type === "tableCell") {
      result += "	";
      if (!skip) content += "	";
    } else if (type === "heading") {
      skip = false;
      if (node.depth > 1) {
        save();
        content = "";
        const hProperties = node.data.hProperties;
        activeSlug = hProperties.id + "#" + result;
      }
    }
    return result;
  }
};
export {
  remarkStructurize
};
