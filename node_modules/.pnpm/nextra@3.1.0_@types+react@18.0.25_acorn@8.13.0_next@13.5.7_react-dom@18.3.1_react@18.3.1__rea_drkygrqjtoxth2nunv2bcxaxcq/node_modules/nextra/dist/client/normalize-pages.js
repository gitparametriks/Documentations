import { ERROR_ROUTES } from "../constants.js";
const DEFAULT_PAGE_THEME = {
  breadcrumb: true,
  collapsed: false,
  footer: true,
  layout: "default",
  navbar: true,
  pagination: true,
  sidebar: true,
  timestamp: true,
  toc: true,
  typesetting: "default"
};
function extendMeta(_meta = {}, fallback, metadata = {}) {
  const theme = {
    ...fallback.theme,
    ..._meta.theme,
    ...metadata.theme
  };
  return {
    ...fallback,
    ..._meta,
    display: metadata.display || _meta.display || fallback.display,
    theme
  };
}
function findFirstRoute(items) {
  for (const item of items) {
    if (item.route) return item.route;
    if (item.children) {
      const route = findFirstRoute(item.children);
      if (route) return route;
    }
  }
}
function normalizePages({
  list,
  route,
  docsRoot = "",
  underCurrentDocsRoot = false,
  pageThemeContext = DEFAULT_PAGE_THEME
}) {
  let meta = {};
  let metaKeys = [];
  const items = [];
  for (const [index, item] of list.entries()) {
    if ("data" in item) {
      meta = item.data;
      metaKeys = Object.keys(meta).filter((key) => key !== "*");
      for (const key of metaKeys) {
        if (typeof meta[key] !== "string") continue;
        meta[key] = { title: meta[key] };
      }
      continue;
    }
    const prevItem = list[index - 1];
    if (prevItem && prevItem.name === item.name) {
      items[items.length - 1] = {
        ...prevItem,
        withIndexPage: true,
        // @ts-expect-error fixme
        frontMatter: item.frontMatter
      };
      continue;
    }
    items.push(item);
  }
  items.sort((a, b) => {
    const indexA = metaKeys.indexOf(a.name);
    const indexB = metaKeys.indexOf(b.name);
    if (indexA === -1 && indexB === -1) return a.name < b.name ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
  for (const [index, metaKey] of metaKeys.entries()) {
    const metaItem = meta[metaKey];
    const item = items.find((item2) => item2.name === metaKey);
    if (metaItem.type === "menu") {
      if (item) {
        item.items = metaItem.items;
        if (typeof window === "undefined") {
          const { children } = items.find(
            (i) => i.name === metaKey
          );
          for (const [key, value] of Object.entries(
            item.items
          )) {
            if (!value.href && children.every((i) => i.name !== key)) {
              throw new Error(
                `Validation of "_meta" file has failed.
The field key "${metaKey}.items.${key}" in \`_meta\` file refers to a page that cannot be found, remove this key from "_meta" file.`
              );
            }
          }
        }
      }
    }
    if (item) continue;
    if (typeof window === "undefined") {
      const isValid = metaItem.type === "separator" || metaItem.type === "menu" || metaItem.href;
      if (!isValid) {
        throw new Error(
          `Validation of "_meta" file has failed.
The field key "${metaKey}" in \`_meta\` file refers to a page that cannot be found, remove this key from "_meta" file.`
        );
      }
    }
    const currentItem = items[index];
    if (currentItem && currentItem.name === metaKey) continue;
    items.splice(
      index,
      // index at which to start changing the array
      0,
      // remove zero items
      { name: metaKey, ...meta[metaKey] }
    );
  }
  const directories = [];
  const flatDirectories = [];
  const docsDirectories = [];
  const flatDocsDirectories = [];
  const topLevelNavbarItems = [];
  const { title: _title, href: _href, ...fallbackMeta } = meta["*"] || {};
  let activeType = fallbackMeta.type;
  let activeIndex = 0;
  let activeThemeContext = {
    ...pageThemeContext,
    ...fallbackMeta.theme
  };
  let activePath = [];
  for (const currentItem of items) {
    const extendedMeta = extendMeta(
      meta[currentItem.name],
      fallbackMeta,
      currentItem.frontMatter
    );
    const { display, type = "doc" } = extendedMeta;
    const extendedPageThemeContext = {
      ...pageThemeContext,
      ...extendedMeta.theme
    };
    const isCurrentDocsTree = route.startsWith(docsRoot);
    const normalizedChildren = currentItem.children && normalizePages({
      list: currentItem.children,
      route,
      docsRoot: type === "page" || type === "menu" ? currentItem.route : docsRoot,
      underCurrentDocsRoot: underCurrentDocsRoot || isCurrentDocsTree,
      pageThemeContext: extendedPageThemeContext
    });
    const title = extendedMeta.title || type !== "separator" && (currentItem.frontMatter?.sidebarTitle || currentItem.frontMatter?.title || currentItem.name);
    const getItem = () => ({
      ...currentItem,
      type,
      ...title && { title },
      ...display && { display },
      ...normalizedChildren && { children: [] }
    });
    const item = getItem();
    const docsItem = getItem();
    const pageItem = getItem();
    docsItem.isUnderCurrentDocsTree = isCurrentDocsTree;
    if (type === "separator") {
      item.isUnderCurrentDocsTree = isCurrentDocsTree;
    }
    if (currentItem.route === route) {
      activePath = [item];
      activeType = type;
      activeThemeContext = {
        ...activeThemeContext,
        ...extendedPageThemeContext
      };
      switch (type) {
        case "page":
        case "menu":
          activeIndex = topLevelNavbarItems.length;
          break;
        case "doc":
          activeIndex = flatDocsDirectories.length;
      }
    }
    if (ERROR_ROUTES.has(currentItem.route)) {
      continue;
    }
    const isHidden = display === "hidden";
    if (normalizedChildren) {
      if (normalizedChildren.activeIndex !== void 0 && normalizedChildren.activeType !== void 0) {
        activeThemeContext = normalizedChildren.activeThemeContext;
        activeType = normalizedChildren.activeType;
        if (isHidden) {
          continue;
        }
        activePath = [
          item,
          // Do not include folder which shows only his children
          ...normalizedChildren.activePath.filter(
            (item2) => item2.display !== "children"
          )
        ];
        switch (activeType) {
          case "page":
          case "menu":
            activeIndex = topLevelNavbarItems.length + normalizedChildren.activeIndex;
            break;
          case "doc":
            activeIndex = flatDocsDirectories.length + normalizedChildren.activeIndex;
            break;
        }
        if (currentItem.withIndexPage && type === "doc") {
          activeIndex++;
        }
      }
      switch (type) {
        case "page":
        case "menu":
          pageItem.children.push(...normalizedChildren.directories);
          docsDirectories.push(...normalizedChildren.docsDirectories);
          if (normalizedChildren.flatDirectories.length) {
            const route2 = findFirstRoute(normalizedChildren.flatDirectories);
            if (route2) pageItem.firstChildRoute = route2;
            topLevelNavbarItems.push(pageItem);
          } else if (pageItem.withIndexPage) {
            topLevelNavbarItems.push(pageItem);
          }
          break;
        case "doc":
          docsItem.children.push(...normalizedChildren.docsDirectories);
          if (item.withIndexPage && display !== "children") {
            flatDocsDirectories.push(docsItem);
          }
      }
      flatDirectories.push(...normalizedChildren.flatDirectories);
      flatDocsDirectories.push(...normalizedChildren.flatDocsDirectories);
      item.children.push(...normalizedChildren.directories);
    } else {
      if (isHidden) {
        continue;
      }
      flatDirectories.push(item);
      switch (type) {
        case "page":
        case "menu":
          topLevelNavbarItems.push(pageItem);
          break;
        case "doc": {
          const withHrefProp = "href" in item;
          if (!withHrefProp) {
            flatDocsDirectories.push(docsItem);
          }
        }
      }
    }
    if (isHidden) {
      continue;
    }
    if (type === "doc" && display === "children") {
      if (docsItem.children) {
        directories.push(...docsItem.children);
        docsDirectories.push(...docsItem.children);
      }
    } else {
      directories.push(item);
    }
    switch (type) {
      case "page":
      case "menu":
        docsDirectories.push(pageItem);
        break;
      case "doc":
        if (display !== "children") {
          docsDirectories.push(docsItem);
        }
        break;
      case "separator":
        docsDirectories.push(item);
    }
  }
  const result = {
    activeType,
    activeIndex,
    activeThemeContext,
    activePath,
    directories,
    flatDirectories,
    docsDirectories,
    flatDocsDirectories,
    topLevelNavbarItems
  };
  return result;
}
export {
  normalizePages
};
